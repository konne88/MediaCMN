# MediaCMN - Tools to create a consistent music library.
# Copyright (C) 2009 Konstantin Weitz
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

import getopt
import os

import check
from share.index import IndexReference

class CommonCmnOptions(object):
	def __init__(self,name='',desc=''):
		"""
		This class enables a simple and consistant commandline
		interface. All parameters are parsed here and help information
		is autogenerated. `name` is the name of the commandline
		application, `desc` is a short description of what the it does.
		If you derive from this class, append option to the `_opts` 
		variable. The need to be in the format
		(long option,short option,parameter name,description)
		use None if not used. To interpret the options you should
		implement the `_set_option_value` function.
		"""
		self._index = os.path.expanduser("~/cmn_index.db")
		self._email = "konnew@gmx.de"
		self._appname = name
		self._appdesc = desc

		self._appargs = "[OPTION...]"
		self._opts = [
			('help','h',None,"display this help and exit",False),
			('index','i',"DBFILE",
				"DBFILE is the name of the sqlite database file used to store the index",
				self._index)
		]
	
	@property
	def index_reference(self):
		"""Return a reference to a database. Pass to constructor of
		`Index` in order to connect to a database."""
		return IndexReference(self._index)

	def usage(self):
		"""Prints an autogenerated help about this application"""
		
		print "Usage: %s %s" % (self._appname,self._appargs)
		print self._appdesc
		print
		print "Mandatory arguments to long options are mandatory for short options too."
		
		for o in self._opts:
			# writes short option
			if o[1] != None:
				s = '  -'+o[1]+', '
			else:
				s = '      '
			
			# write long option
			s+='--'+o[0]
			if o[2] != None:
				s+='=%s'%o[2]
			s+=' '
			
			# fill ip with spaces
			l = len(s)
			if l < 30:
				s += ' '*(30-l)
			
			# write message
			s+=o[3].replace('\n','\n'+30*' ')
			
			# write default value
			if o[2] == None:
				if o[4] == True:
					s+='\n'+30*' '+"(enabled by default)"
			elif o[4] != None:
				v = unicode(o[4])
				if v == '':
					v = "is an empty string"
				s+='\n'+30*' '+"(default %s)" % v
			
			# print the string
			print s
			
		print
		print "Report bugs to <%s>" % self._email
	
	def _handle_unused_args(self,args):
		"""
		Called with all the arguments passed to the application
		that weren't used. Useful to implement the passing of files.
		Return None if no error occured.
		"""
		return None
	
	def _all_options_loaded(self):
		"""
		Called once all options were loaded. A good way to check if the
		passed options are actually mixable.
		Return None if no error occured.
		"""
		return None
	
	def _set_option_value(self,opt,val):
		"""
		Called for each option that is found. `opt` is the long name
		of the option, `val` the value as a string.
		Return None if no error occured.
		"""
		q = None
		if opt == 'help':
			q = 0
		elif opt == 'index':
		  	if val == None:
		  		print "Passed index is not a valid database."
		  		q = 1
		  	else:
		  		self.index = val
		return q

	def print_sep(self):
		"""Call to seperate content on the commandline."""
		print '----------------------------------------------'		
		
	def print_init(self):
		"""Call once the application started running."""
		print 'Starting',self._appname
		self.print_sep()

	def print_done(self):
		"""Call once the application terminated succesfully."""
		print self._appname, "done"
		self.print_sep()

	def print_terminated(self):
		"""Call if the application was killed."""
		print
		self.print_sep()
		print self._appname, "terminated"
		self.print_sep()

	def parse_cmdline_arguments(self,argv):
		"""
		Call to parse the commandline arguments
		passed to your application.
		"""
		self.appname = argv[0]
		argv = argv[1:]
		quit = None
		
		sopts =''
		lopts =[]
		for o in self._opts:
			sopts+=o[1]
			lopt=o[0]
			if o[2]:
				sopts+=':'
				lopt+='='
			lopts.append(lopt)
			
		try:
			params, args = getopt.getopt(argv, sopts, lopts) 

			for param, arg in params:
				for o in self._opts:
					if param in ('--'+o[0],'-'+o[1]):					
						if o[2] != None:
							q = self._set_option_value(o[0],arg)
						else:
							q = self._set_option_value(o[0],True)
						
						if q!=None:
							quit = q
						
						break
				
			q = self._handle_unused_args(args)
			if q!=None:
				quit = q
			
			q = self._all_options_loaded()
			if q!=None:
				quit = q
		
		except getopt.GetoptError, e:
			print e
			quit = 1
		
		if quit != None:
			self.usage()
			exit(quit)


class IndexOptions(CommonCmnOptions):
	def __init__(self):
		super(IndexOptions,self).__init__()
		self.drop = False
		self._opts.append(('drop','d',None,
			"start by deleting all database entries",self.drop))
	
	def _set_option_value(self,opt,val):
		q = None

		if opt == 'drop':
			self.drop = val
		else:
			r = super(IndexOptions,self)._set_option_value(opt,val)
			if r != None:
				q = r
		return q
		
